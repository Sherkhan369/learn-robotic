---
sidebar_position: 2
title: "Chapter 2: ROS 2 Nodes and Communication"
description: "Deep dive into ROS 2 nodes, topics, and message passing"
---



## ROS 2 Nodes and Communication

This chapter explores ROS 2 nodes and communication mechanisms in detail, focusing on how different components of a robotic system communicate with each other.

### Understanding Nodes (Simple Explanation)

Think of a **node** as a single program that does one specific job. In a robot, you might have:

- A "camera node" that takes pictures
- A "motor node" that moves the wheels
- A "navigation node" that decides where to go

#### Simple Communication Example:
```
Camera Node → "I see an obstacle!" → Navigation Node
Navigation Node → "Stop the robot!" → Motor Node
```

### Topics (Communication Channels)

**Topics** are like chat channels where nodes share information. Any node can send messages to a topic (publisher) and any node can listen to a topic (subscriber).

#### Example:
- Topic: `/sensor_data`
- Publisher: Camera node sends images
- Subscriber: Processing node receives images


### Nodes in Depth

A node is an executable that uses ROS 2 to communicate with other nodes. Nodes are organized into a graph structure for processing data in a distributed fashion. Each node is a separate process that can contain multiple publishers, subscribers, services, and actions.

#### Node Creation:
```python
import rclpy
from rclpy.node import Node

class MyNode(Node):
    def __init__(self):
        super().__init__('my_node_name')
        # Node initialization code
```

### Topics and Publishers/Subscribers

Topics enable asynchronous communication through a publish/subscribe model where publishers send messages to topics and subscribers receive messages from topics. This creates a decoupled communication pattern where publishers don't need to know about subscribers.

#### Creating Publisher and Subscriber:
```python
# Publisher
self.publisher = self.create_publisher(String, 'topic_name', 10)

# Subscriber
self.subscriber = self.create_subscription(
    String, 'topic_name', self.listener_callback, 10)
```


### Advanced Node Concepts

Nodes in ROS 2 implement the `rcl` (ROS Client Library) interface and can be created in multiple languages (C++, Python, etc.). Advanced node features include:

- **Node Composition**: Running multiple nodes in the same process to reduce communication overhead
- **Node Parameters**: Runtime configurable values with type safety
- **Node Lifecycle**: Managed state transitions (unconfigured → inactive → active → finalized)

#### Memory Management:
Nodes manage their own memory for message allocation and deallocation, with support for zero-copy message passing in some configurations.

#### Quality of Service (QoS):
Advanced QoS profiles allow fine-tuning communication behavior:
- Reliability: Best effort vs reliable
- Durability: Volatile vs transient local
- History: Keep last N messages vs keep all


### Communication Patterns

#### Basic Communication
The two main ways nodes communicate:

1. **Publish/Subscribe** - One-way broadcast (like radio)
2. **Request/Response** - Two-way conversation (like phone call)

**When to use which:**
- Use publish/subscribe for sensor data, status updates
- Use request/response for commands, queries


#### Communication Patterns in Detail

1. **Publishers/Subscribers (Topics)**:
   - Asynchronous, one-to-many communication
   - Uses message queues with configurable size
   - Data is sent as messages defined in `.msg` files

2. **Clients/Services**:
   - Synchronous, one-to-one communication
   - Request-response pattern
   - Used for actions that require acknowledgment

3. **Actions**:
   - Asynchronous, long-running tasks
   - Provides feedback during execution
   - Supports goal preemption and result reporting


#### Advanced Communication Features

**ROS Middleware (RMW)**:
- Abstraction layer over DDS implementations
- Supports multiple DDS vendors (Fast DDS, Cyclone DDS, RTI Connext)
- Provides vendor-agnostic interface

**Intra-process Communication**:
- Zero-copy communication within same process
- Requires special intraprocess manager
- Significant performance improvement for co-located nodes

**Message Filters**:
- Time synchronization for multi-sensor data
- Approximate time synchronization
- Type conversion and validation



